# 調査レポート: ユーザ認証（kash / nats）実装調査

作成日: 2025-11-11

目的:
- アプリケーションにユーザ認証を導入し、ID: `kash` / password: `nats` でログインできるようにする手順を調査する。
- 参照資料として igakilab/springboot_samples を利用する。

制約:
- 本フェーズは「調査フェーズ」であり、ここではコードの実装は行わない。
- 実装方針や対象ファイル、手順、検証方法（DoD）を提案する。

調査結果サマリ:
- Spring Boot + Spring Security を利用してフォームログインを実装するのが一般的で簡単。短時間で動作確認する場合は in-memory のユーザ定義が最も手早い。
- カスタムログイン画面を用意する場合は Thymeleaf 等のテンプレート（`src/main/resources/templates/login.html`）を用意し、Security 設定で `loginPage("/login")` を指定する。
- パスワードは平文で保持せず、`PasswordEncoder`（推奨: `BCryptPasswordEncoder`）でハッシュ化して扱う。開発検証時でも Encoder を使っておくことを推奨。
- Spring Boot のバージョンにより設定方法が変わる。最近のバージョンでは WebSecurityConfigurerAdapter が非推奨であるため、`SecurityFilterChain` を定義する方法（@Bean）を採るのが望ましい。

実装の選択肢（短評）:
1. in-memory ユーザ
   - 長所: 実装が簡単。パスワードをコード上で定義できるため開発・検証が早い。
   - 短所: 本番向けではない（リロードで消える、複数ユーザ管理不可）。
2. application.properties による spring.security.user の利用
   - 長所: さらに簡単、設定ファイルのみで済む。
   - 短所: デフォルトのユーザ名は `user` などの挙動があり、カスタムログイン画面と組み合わせる場合は設定が限定的。
3. JDBC ユーザ（データベースを使ったユーザ管理）
   - 長所: 本番運用向け。ユーザ追加・管理が容易。
   - 短所: スキーマ準備、マイグレーションが必要。今回の要求では過剰。
4. LDAP / OIDC 等
   - 長所: 企業向け SSO 等に利用。
   - 短所: 今回は不要。

推奨方針（本プロジェクト向け）:
- まずは in-memory 認証で `kash`/`nats` を実装して動作確認する。
- 実装の要点:
  1. `PasswordEncoder` を登録（例: `BCryptPasswordEncoder`）。
  2. `UserDetailsService` または in-memory 形式でユーザを登録（パスワードは encoder でエンコードした値を設定）。
  3. `SecurityConfig` クラスを作成/編集し、`SecurityFilterChain` を定義してフォームログインを許可。カスタムログイン画面を使う場合は `loginPage("/login")` を設定する。
  4. ログイン画面を `src/main/resources/templates/login.html`（Thymeleaf）または `src/main/resources/static/index.html` に作成し、POST を `/login` に送るようにする。

対象となるファイル（ワークスペースのルートからの相対パス）:
- `src/main/java/team2/nats/config/SecurityConfig.java`  （新規作成または編集）
- `src/main/resources/templates/login.html` （カスタムログイン画面。Thymeleaf を使う場合）
- `src/main/resources/static/index.html` （簡易的に静的ページでログインフォームを置く場合）
- `src/main/resources/application.properties` （必要に応じて設定追加）
- `docs/tasks.md` （実装フェーズに移る場合はここにタスクとして記載する）

実装手順（概略）:
1. `docs/tasks.md` に実装タスクを記載（本調査の内容に基づく）。
2. main ブランチにいることを確認し、新しいブランチ（例: `feat/add-login-kash`）を作成する。
3. `SecurityConfig.java` を作成し、`PasswordEncoder` と in-memory ユーザ（kash）を登録する。`SecurityFilterChain` を定義してフォームログインを有効化する。
4. ログインページを作成（`templates/login.html`）。ログイン失敗時の表示や CSRF トークンを含める。
5. `gradle bootRun` で起動し、ブラウザでログイン動作を確認する。
6. 動作確認後、`docs/reports/done/done_YYYY-MM-DD_ログイン実装.md` を作成し、手順と検証方法を記録する。

検証方法（DoD: Definition of Done）:
- `./gradlew bootRun` でアプリを起動できること。
- ブラウザで `http://localhost:8080/` にアクセスし、ログイン画面が表示されること（カスタム画面を使用する場合）。
- ユーザ名 `kash`、パスワード `nats` でログイン可能で、認証が必要なページにアクセスできること。
- ログイン失敗時に適切なエラーメッセージが表示されること。

参考・リンク:
- igakilab/springboot_samples: https://github.com/igakilab/springboot_samples
  - 上記リポジトリ内の "Spring Security" 関連サンプル（form login や basic auth の例）を参照すると実装例が分かりやすい。
- Spring Security 公式ドキュメント（認証の基本、PasswordEncoder、フォームログイン）: https://spring.io/projects/spring-security

注意点・補足:
- Spring Boot のバージョンに依存して設定方法が異なるため、`build.gradle` の Spring Boot バージョンを確認すること。最近のバージョンでは `WebSecurityConfigurerAdapter` は非推奨であり、`SecurityFilterChain` を用いた設定が推奨される。
- パスワードを平文でリポジトリに残さないこと。本番では環境変数やシークレット管理を用いる。

次のアクション候補（ユーザが選べる）:
1. この調査内容で実装を進めてほしい -> 「実装」を指示してください（指示があれば実装フェーズに移行し、`docs/tasks.md` にタスクを記載してから実装します）。
2. JDBC や外部認証に移行したい -> 要件を提示してください（DB 種類、ユーザテーブルの有無、マイグレーション方針など）。

作業報告:
- 本調査では、実装方針の候補と推奨方針（in-memory での検証）、対象ファイル、手順、DoD、および参考資料をまとめた。
- 次にユーザが取れる行動: 実装を実行するなら「実装」を指示してください。実装に移る際は main ブランチ確認と新規ブランチ作成を行い、実装を開始します。
